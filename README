I didn't like the "mock" module, so I'm making one myself for educational purposes.

The goal is to be able to write something like this:

    class Calc(object):
        def sum(self, a, b):
            return a + b

    # 2 + 2 = 4? Not for long!
    mock = mockaccino.createMock(Calc)

    mock.sum(2, 2).will_return(5)

    mockaccino.replay(mock)

    assert mock.sum(2, 2) == 5 # Take that, math!

It's a work in progress.

Changelog

Feb142012 - 11AM

- Implemented times and will_raise method modifier

  Now you should be able to do something like:
  
    mock = mockaccino.createMock(self.MockedClass)
    mock.method_that_returns_an_int().will_raise(ValueError)
    mockaccino.replay(mock)
    mock.method_that_returns_an_int()

  And it will raise a ValueError or

    mock = mockaccino.createMock(self.MockedClass)
    mock.method_that_returns_an_int().times(2)
    mockaccino.replay(mock)
    mock.method_that_returns_an_int()
    mock.method_that_returns_an_int()
    mock.method_that_returns_an_int()

  And it will raise an UnexpectedCall error on the third call.

  The nexts steps are adding more tests, value checks to the will_raise
  and times methods to increase robustness, add an will_return modifier.
  The last one pretty likely will require a mass refactoring. Oops.
